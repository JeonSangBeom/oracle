--서브 쿼리안에 또 다른 쿼리 쓰기
--SELECT(메인 쿼리) 안에 SELECT(서브 쿼리) 쓰기

SELECT SAL 
FROM EMP
WHERE ENAME = 'JONES'; -->조건

--JONES 보다 월급이 높은 사람
SELECT * 
FROM EMP
WHERE SAL > 2975;

--서브쿼리 이용으로 바로 사용 가능
SELECT * 
FROM EMP
WHERE SAL > (
            SELECT SAL
            FROM EMP
            WHERE ENAME = 'JONES'
            ); -->단일행 리턴 하는 이것을 중첩 서브 쿼리라고 칭한다(다중행 가능)
            
--서브 쿼리 이용하여 EMP에서 이름이 ALLEN의 추가 수당보다 많은 추가 수당을 받는 애 뽑기
SELECT *
FROM EMP
WHERE COMM > (
            SELECT COMM
            FROM EMP
            WHERE ENAME = 'ALLEN'
            );
            
--BLAKE의 입사일 보다 늦게 입사한 사람
SELECT *
FROM EMP
WHERE HIREDATE > (
                SELECT HIREDATE
                FROM EMP
                WHERE ENAME = 'BLAKE'
                );
                
--20번 부서에 속한 사람 중 전체 사원의 평균 급여 보다 높은 급여를 받는 사람 정보 출력
SELECT E.EMPNO,E.ENAME,E.JOB,E.SAL,D.DEPTNO,D.DNAME,D.LOC
--같은 테이블이 아니기 때문에 조인해 주어야 한다 DEPT 풀네임을 앞에 쓰면 길기에 별명 사용
FROM EMP E, DEPT D-->D.DEPTNO,D.DNAME,D.LOC (D와 C로 별명 사용하여 편하게 사용)
WHERE E.DEPTNO = D.DEPTNO 
AND E.DEPTNO = 20 --20번 부서
AND E.SAL > (SELECT TRUNC(AVG(SAL)) FROM EMP);   -- 전체사원의 평균 급여


-- IN,ANY,SOME,ALL - 조건이 하나가 아닐때 사용
-- 실행결과가 여러개 나올 경우

--주로 IN을 많이 사용한다
SELECT *
FROM EMP 
WHERE DEPTNO IN(20,30);--20번 또는 30번인 부서(IN안에 다중행 함수 사용 가능)

-- 각 부서의 최고 급여를 받는 사람 구하기
SELECT *
FROM EMP
WHERE SAL IN (SELECT MAX(SAL)
              FROM EMP
              GROUP BY DEPTNO)
              ORDER BY DEPTNO;

--이퀄 = 등 을 앞에 써준다 / 값을 뽑아올때 주로 사용
--ANY, SOME 값이 하나라도 있으면 만족(TRUE)
--ALL 조건을 전부 만족해야만 TRUE를 리턴한다
SELECT *
FROM EMP
WHERE SAL = SOME (SELECT MAX(SAL)
                 FROM EMP
                 GROUP BY DEPTNO);
                 
SELECT *
FROM EMP
WHERE SAL = ANY(1000,2000,3000); 
--> SAL이 에 셋중 하나라도 있으면 값이 떨어진다
--> ALL일 경우는 없는 것으로 나온다(세가지 값을 전부 만족하여야 하기 때문)
         
-- EXISTS 존재하면 값을 찾아 준다
SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME 
              FROM DEPT
              WHERE DEPTNO = 10
              );
    
--EMP에서 10번 부서에 속한 모든 사원들 보다 일찍 입사한 사람    
SELECT *
FROM EMP -- 행과 열만 있으면 TABLE이다
WHERE HIREDATE < ALL
                (
                SELECT HIREDATE 
                FROM EMP
                WHERE DEPTNO = 10
                );
-- WHERE 절에 쓰는 서브 쿼리 - 중첩 서브 쿼리
-- FROM 절에 쓰는 서브쿼리를 보통 인라인 뷰(전체 테이블에서 일부만 마스킹 해서 뷰로 만드는 것)

-- FROM(인라인 뷰) 절 사용 법
SELECT * 
FROM EMP
WHERE DEPTNO = 10;

SELECT * 
FROM DEPT;

--서브쿼리  / 조인
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E10, -->EMP E10과 같은 것
     (SELECT * FROM DEPT) D -->DEPT D
WHERE E10.DEPTNO = D.DEPTNO;      

--WHERE절이 아닌 SELECT절 이용 
--SELECT절 - 스칼라 서브쿼리(컬럼명에 쓰는 쿼리/무조건 단일행)
--WHERE는 다중행 가능
SELECT EMPNO, ENAME, JOB, SAL,
        (SELECT GRADE FROM SALGRADE WHERE E.SAL BETWEEN LOSAL AND HISAL) AS SALGRADE,
        DEPTNO,
        (SELECT DNAME FROM DEPT WHERE E.DEPTNO = DEPT.DEPTNO) AS DNAME
FROM EMP E;
--SELECT GRADE FROM SALGRADE;

--연습 문제 
--0901번
SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND JOB = (SELECT JOB FROM EMP WHERE ENAME = 'WARD');
--> (SELECT JOB FROM EMP WHERE ENAME = 'WARD')여기 해당되는 직업(중첩서브쿼리 사용법)
--> 바로 직업인 'SALESMAN'을 써도 된다


--0902번
SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO 
AND E.SAL > (SELECT TRUNC(AVG(SAL)) FROM EMP)
AND E.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY E.SAL DESC, E.EMPNO; -->DESC(뒤집어 표시 할때)


--0903번
SELECT E.EMPNO, E.ENAME, E.JOB, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.DEPTNO = 10
AND E.JOB NOT IN(SELECT JOB FROM EMP WHERE DEPTNO = 30);

--SELECT JOB FROM EMP WHERE DEPTNO = 30; 30번 부서의 JOB

--0904번-01
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
AND E.SAL > (SELECT MAX(SAL)FROM EMP WHERE JOB = 'SALESMAN')
ORDER BY E.EMPNO;

SELECT MAX(SAL)
FROM EMP
WHERE JOB = 'SALESMAN';

--0904번-02 다중행
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
AND E.SAL > ALL(SELECT SAL FROM EMP WHERE JOB = 'SALESMAN') --ANY,ALL,IN
ORDER BY E.EMPNO;

--부서 번호 20번에 있는 사원들의 급여에서 해당하는 JOB의 평균 급여의 차이를 구해보세요

SELECT E.EMPNO, E.ENAME, E.JOB,E.SAL,
E.SAL - (SELECT TRUNC(AVG(SAL)) AS AVG FROM EMP EE WHERE E.JOB = EE.JOB) AS AVG_SAL_DIFF
FROM EMP E
WHERE DEPTNO =20;

SELECT JOB, TRUNC(AVG(SAL)) AS AVG
FROM EMP
WHERE DEPTNO = 20
GROUP BY JOB;






----TABLE 만들어서 데이터 넣어보기---------


------INSERT UPDATE DELETE ----

--DROP - 테이블을 지울떄 사용
DROP TABLE DEPT_TEMP;
CREATE TABLE DEPT_TEMP
    AS SELECT * FROM DEPT ;
    --AS SELECT * FROM DEPT WHERE 1 = 0;
--> 복사할때 AS 를 사용(TABLE 복제)
--> WHERE 1 = 0; 껍데기만 가져올때 이런 조건자를 써둔다
-->TABLE을 만들고 네임 써주기

SELECT *FROM DEPT_TEMP;

--추가로 넣고 싶을때
INSERT INTO DEPT_TEMP (DEPTNO,DNAME,LOC)
VALUES (50, 'DATABASE', 'SEOUL');

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (60, 'JAVA', 'BUSAN'); --> 정해진 갯수 중요 / 생략은 가능(NULL)

INSERT INTO DEPT_TEMP --> 생략도 가능하다
VALUES (70,'NETWORK','DANGSAN');

INSERT INTO DEPT_TEMP
VALUES (80,'WEB',NULL);-->공백 또는 NULL값을 넣어주면 된다


----EMP 복제해서 본인 데이터 넣어보기
DROP TABLE EMP_TEMP;
CREATE TABLE EMP_TEMP
    AS SELECT * FROM EMP;
    
SELECT * FROM EMP_TEMP;    

INSERT INTO EMP_TEMP
VALUES ('1','전상범','학생',NULL,'2021-10-21',NULL,NULL,NULL);

INSERT INTO EMP_TEMP
VALUES ('1','전상범','학생',NULL,SYSDATE,NULL,NULL,NULL);

INSERT INTO EMP_TEMP
SELECT E.*
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 1;
-->서브 쿼리로 넣을 경우 VALUES를 쓰지 않는다

--UPDATE - 무조건 조건을 달아서 사용해야 한다
CREATE TABLE DEPT_TEMP02
AS SELECT * FROM DEPT;

--DML

UPDATE DEPT_TEMP02
SET LOC = 'SEOUL',-->LOC의 데이터 변경 / 조건이 없을 경우 전부 바뀐다
    DNAME = 'DB'
WHERE DEPTNO = 40;

COMMIT;--> 저장(되둘릴 수 없다)
ROLLBACK; --> COMMIT전에는 다시 원상복구 시킬 수 있다

SELECT * FROM DEPT_TEMP02;

SELECT * FROM EMP_TEMP;
--2500 이하인 사람은 COMM 50

UPDATE EMP_TEMP
SET COMM = 50
WHERE SAL <= 2500;

ROLLBACK;
COMMIT;

----DELETE
DELETE FROM EMP_TEMP
WHERE JOB = 'CLERK';

SELECT * FROM EMP_TEMP;

--30번 부서에 GRADE =3
DELETE FROM EMP_TEMP --> 전부 삭제(조건 필요)
WHERE EMPNO IN(
SELECT EMPNO 
FROM EMP_TEMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
AND S.GRADE = 3
AND E.DEPTNO = 30);

SELECT * FROM SALGRADE;

ROLLBACK;

SELECT * FROM EMP_TEMP;

--INSERT INTO TABLE명 () VALUES ();
--DELETE FROM TABLE명 WHERE 조건;
--UPDATE TABLE명 SET 컬러명 WHERE 조건;

CREATE TABLE CHAP10HW_EMP
AS SELECT * FROM EMP;

CREATE TABLE CHAP10HW_DEPT
AS SELECT * FROM DEPT;

CREATE TABLE CHAP10HW_SALGRADE
AS SELECT * FROM SALGRADE;

INSERT INTO CHAP10HW_DEPT(DEPTNO,DNAME,LOC) VALUES(50,'ORACLE','BUSAN');
INSERT INTO CHAP10HW_DEPT(DEPTNO,DNAME,LOC) VALUES(60,'SQL','ILSAN');
INSERT INTO CHAP10HW_DEPT(DEPTNO,DNAME,LOC) VALUES(70,'SELECT','INCHEON');
INSERT INTO CHAP10HW_DEPT(DEPTNO,DNAME,LOC) VALUES(80,'DML','BUNDANG');

ROLLBACK;

SELECT * FROM CHAP10HW_DEPT;

COMMIT;

INSERT INTO CHAP10HW_EMP VALUES(7201, 'TEST_USER','MANAGER',7788,TO_DATE('2016-01-02','YYYY-MM-DD-'),4500,NULL,50);
--values (7201,'TEST_USER1','MANAGER',7788,'2016/01/02',4500,NULL,50);
--values (7202,'TEST_USER2','CLERK',7201,'2016/02/21',1800,NULL,50);
--values (7203,'TEST_USER3','ANALYST',7201,'2016/04/11',3400,NULL,60);
--values (7204,'TEST_USER4','SALESMAN',7201,'2016/05/31',2700,300,60);
--values (7205,'TEST_USER5','CLERK',7201,'2016/07/20',2600,NULL,70);
--values (7206,'TEST_USER6','CLERK',7201,'2016/09/08',2600,NULL,70);
--values (7207,'TEST_USER7','LECTURER',7201,'2016/10/28',2300,NULL,80);
--values (7208,'TEST_USER8','STUDENT',7201,'2018/03/09',1200,NULL,80);

SELECT * FROM CHAP10HW_EMP;
COMMIT;


UPDATE CHAP10HW_EMP
SET DEPTNO = 70
WHERE SAL >(SELECT AVG(SAL) FROM CHAP10HW_EMP
WHERE DEPTNO = 50);

UPDATE CHAP10HW_EMP
SET SAL = SAL*1.1,
    DEPTNO = 80
WHERE HIREDATE > (SELECT MIN(HIREDATE) FROM CHAP10HW_EMP WHERE DEPTNO = 60);
ROLLBACK;
COMMIT;

DELETE FROM CHAP10HW_EMP
WHERE EMPBO = (SELECT E.EMPNO
                FROM CHAP10HW_EMP E, CHAP10HW_SALGRADE S
                WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 5);
                
SELECT * FROM CHAP10HW_EMP;


-------------TRANSACTION-----------------

--다른 SCOTT 생성 
 -->동시에 두군데에서 접속을 할 경우 오류 발생(LOCK걸림) / 각 위치에서 COMMIT을 꼭 해야 함
    -->한쪽을 COMMIT을 해야지만 가능 다음 서버에서 접속 가능하게 됨

DROP TABLE DEPT_TCL;
CREATE TABLE DEPT_TCL
AS SELECT * FROM DEPT;

INSERT INTO DEPT_TCL VALUES (50,'DATABASE','INCHEON');
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;
DELETE FROM DEPT_TCL WHERE DEPTNO = 50;
SELECT * FROM DEPT_TCL;

ROLLBACK;

COMMIT;

UPDATE DEPT_TCL SET DNAME = 'JAVA'
WHERE DEPTNO = 10;

SELECT * FROM DEPT_TCL;


--DML ---> INSERT UPDATE DELETE (COMMIT/ROLLBACK)
--DDL ---> TABLE 만들기...

DROP TABLE EMP_DDL;

--DDL TABLE/INDEX/VIEW 만드는 DB명령어 (COMMIT/ROLLBACK는 없다)
CREATE TABLE EMP_DDL(-->'_'이것만 쓸 수 있다
  ENPNO VARCHAR2(4) NOT NULL, -->NULL 갑ㅅ을 입력하면 안된다
  ENAME VARCHAR2(10),
  JOB   VARCHAR2(9),
  MGR   NUMBER(4),
  HIREDATE  DATE,
  SAL   NUMBER(7,2), --> 7개 두번째 소숫점 올
  COMM  NUMBER(7,2),
  DEPTNO    NUMBER(2)
);
SELECT * FROM EMP_DDL;
INSERT INTO EMP_DDL VALUES(7877,'KING','PRESIDENT',NULL,TO_DATE('2022-01-18','YYYY-MM-DD'),5000,NULL, 10);
INSERT INTO EMP_DDL VALUES(7878,'BLAKE','MANAGER',7877,TO_DATE('2020-01-10','YYYY-MM-DD'),3000,NULL, 20);
INSERT INTO EMP_DDL VALUES(1001,'SCOTT','FREE',7877,SYSDATE,5000,NULL, NULL);
INSERT INTO EMP_DDL VALUES(1002,'JANG','FREE',7877,SYSDATE,55555.55,NULL, 10);

CREATE TABLE EMP_DEPT_DDL
AS SELECT E.EMPNO,
FROM EMP E, DEPT D

DROP

---TABLE 변경

ALTER TABLE EMP_ALTER
ADD HP VARCHAR2(20);

--컬럼 이름 바꾸기
ALTER TABLE EMP_ALTER
RENAME COLUMN HP TO TEL;

--컬럼 이름 바꾸기
ALTER TABLE EMP_ALTER
MODIFY EMPNO NUMBER(5);

DESC EMP_ALTER;

--- 삭제
ALTER TABLE EMP_ALTER
DROP COLUMN HP;

---TABLE 만들때 CREATE 수정할때 ALTER

--TABLE의 이름 바꾸기
RENAME EMP_ALTER TO EMP_RENAME;

DESC EMP_RENAME;

SELECT * FROM EMP_RENAME;

--데이터 지울때
TRUNCATE TABLE EMP_ALTER;
